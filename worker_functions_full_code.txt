# TO√ÄN B·ªò CODE WORKER FUNCTIONS - RemiAq Project

## 1. NewWorker (Constructor)
```go
// NewWorker t·∫°o worker m·ªõi v·ªõi c√°c dependency
func NewWorker(
	sysRepo repository.SystemStatusRepository,
	reminderRepo repository.ReminderRepository,
	userRepo repository.UserRepository,
	fcmSender services.FCMSender,
	schedCalc services.ScheduleCalculator,
	interval time.Duration,
) *Worker {
	return &Worker{
		sysRepo:      sysRepo,
		reminderRepo: reminderRepo,
		userRepo:     userRepo,
		fcmSender:    fcmSender,
		schedCalc:    schedCalc,
		interval:     interval,
	}
}
```

## 2. Start Worker
```go
// Start kh·ªüi ƒë·ªông worker v·ªõi context c√≥ th·ªÉ cancel
func (w *Worker) Start(ctx context.Context) {
	ticker := time.NewTicker(w.interval)
	go func() {
		defer ticker.Stop()
		log.Printf("Worker started (interval=%s)", w.interval.String())
		log.Printf("Worker config: interval=%d seconds", int(w.interval.Seconds()))

		for {
			select {
			case <-ticker.C:
				w.runOnce(ctx)
			case <-ctx.Done():
				log.Println("Worker stopped")
				return
			}
		}
	}()
}
```

## 3. runOnce - X·ª≠ l√Ω m·ªôt chu k·ª≥ worker
```go
// runOnce processes a single worker cycle
func (w *Worker) runOnce(ctx context.Context) {
	// Check if enabled
	enabled, err := w.sysRepo.IsWorkerEnabled(ctx)
	if err != nil {
		log.Printf("Worker: failed to check system status: %v", err)
		return
	}
	if !enabled {
		return
	}

	now := time.Now().UTC()

	// Get all due reminders
	reminders, err := w.reminderRepo.GetDueReminders(ctx, now)
	if err != nil {
		log.Printf("Worker: failed to get due reminders: %v", err)
		_ = w.sysRepo.UpdateError(ctx, fmt.Sprintf("Failed to get due reminders: %v", err))
		return
	}

	if len(reminders) == 0 {
		return
	}

	log.Printf("Worker: Processing %d due reminders", len(reminders))

	// Track errors
	systemErrorOccurred := false

	for _, reminder := range reminders {
		if err := w.processReminder(ctx, reminder, now); err != nil {
			if isSystemFCMError(err) {
				systemErrorOccurred = true
				log.Printf("Worker: SYSTEM FCM ERROR for reminder %s: %v", reminder.ID, err)
				// Disable worker on system error
				_ = w.sysRepo.DisableWorker(ctx)
				return
			}
			log.Printf("Worker: Error processing reminder %s: %v", reminder.ID, err)
		}
	}

	if !systemErrorOccurred {
		_ = w.sysRepo.ClearError(ctx)
	}
}
```

## 4. processReminder - X·ª≠ l√Ω t·ª´ng nh·∫Øc nh·ªü
```go
// processReminder processes a single reminder (FRP + CRP logic)
func (w *Worker) processReminder(ctx context.Context, reminder *models.Reminder, now time.Time) error {
	// Skip snoozed reminders
	if !reminder.SnoozeUntil.IsZero() && reminder.SnoozeUntil.After(now) {
		// Recalc next_action_at and skip
		nextAction := w.schedCalc.CalculateNextActionAt(reminder, now)
		if !nextAction.Equal(reminder.NextActionAt) {
			_ = w.reminderRepo.UpdateNextActionAt(ctx, reminder.ID, nextAction)
		}
		return nil
	}

	// ========================================
	// STEP 1: Check FRP (has priority)
	// ========================================
	if reminder.Type == models.ReminderTypeRecurring && !reminder.NextRecurring.IsZero() {
		if now.After(reminder.NextRecurring) || now.Equal(reminder.NextRecurring) {
			return w.processFRP(ctx, reminder, now)
		}
	}

	// ========================================
	// STEP 2: Check CRP
	// ========================================
	if w.schedCalc.CanSendCRP(reminder, now) {
		return w.processCRP(ctx, reminder, now)
	}

	// ========================================
	// STEP 3: Just recalc next_action_at
	// ========================================
	nextAction := w.schedCalc.CalculateNextActionAt(reminder, now)
	if !nextAction.Equal(reminder.NextActionAt) {
		_ = w.reminderRepo.UpdateNextActionAt(ctx, reminder.ID, nextAction)
	}

	return nil
}
```

## 5. processFRP - X·ª≠ l√Ω Father Recurrence Pattern
```go
// processFRP handles Father Recurrence Pattern trigger
func (w *Worker) processFRP(ctx context.Context, reminder *models.Reminder, now time.Time) error {
	log.Printf("Worker: FRP triggered for reminder %s", reminder.ID)

	// Get user and send notification
	if err := w.sendNotification(ctx, reminder); err != nil {
		return err
	}

	// Update tracking
	reminder.LastSentAt = now
	reminder.CRPCount = 0
	reminder.NextCRP = reminder.NextRecurring

	// Calculate next FRP
	if reminder.RepeatStrategy == models.RepeatStrategyNone {
		// Auto-calculate next FRP
		nextRecurring, err := w.schedCalc.CalculateNextRecurring(reminder, now)
		if err != nil {
			log.Printf("Worker: Warning - failed to calc next FRP for %s: %v", reminder.ID, err)
			nextRecurring = now.Add(24 * time.Hour)
		}
		reminder.NextRecurring = nextRecurring
	}
	// else: crp_until_complete - keep same NextRecurring until user completes

	// Recalc next_action_at
	reminder.NextActionAt = w.schedCalc.CalculateNextActionAt(reminder, now)

	// Update DB
	if err := w.reminderRepo.Update(ctx, reminder); err != nil {
		return fmt.Errorf("failed to update reminder after FRP: %w", err)
	}

	log.Printf("Worker: FRP processed. Next FRP: %s", reminder.NextRecurring)
	return nil
}
```

## 6. processCRP - X·ª≠ l√Ω Child Repeat Pattern
```go
// processCRP handles Child Repeat Pattern (retry) trigger
func (w *Worker) processCRP(ctx context.Context, reminder *models.Reminder, now time.Time) error {
	log.Printf("Worker: CRP triggered for reminder %s (count: %d/%d)", reminder.ID, reminder.CRPCount+1, reminder.MaxCRP)

	// Send notification
	if err := w.sendNotification(ctx, reminder); err != nil {
		return err
	}

	// Update tracking
	reminder.LastSentAt = now
	reminder.CRPCount++

	// Check if one_time and reached quota
	if reminder.Type == models.ReminderTypeOneTime {
		if reminder.MaxCRP == 0 || reminder.CRPCount >= reminder.MaxCRP {
			log.Printf("Worker: One-time reminder reached quota, marking completed")
			reminder.Status = models.ReminderStatusCompleted
			reminder.LastCompletedAt = now
		}
	}

	// Recalc next_action_at
	if reminder.Status != models.ReminderStatusCompleted {
		reminder.NextCRP = now.Add(time.Duration(reminder.CRPIntervalSec) * time.Second)
		reminder.NextActionAt = w.schedCalc.CalculateNextActionAt(reminder, now)
	} else {
		reminder.NextActionAt = time.Time{}
	}

	// Update DB
	if err := w.reminderRepo.Update(ctx, reminder); err != nil {
		return fmt.Errorf("failed to update reminder after CRP: %w", err)
	}

	log.Printf("Worker: CRP processed")
	return nil
}
```

## 7. sendNotification - G·ª≠i th√¥ng b√°o FCM
```go
// sendNotification sends FCM notification to user
func (w *Worker) sendNotification(ctx context.Context, reminder *models.Reminder) error {
	user, err := w.userRepo.GetByID(ctx, reminder.UserID)
	if err != nil {
		return fmt.Errorf("user not found: %w", err)
	}

	if !user.IsFCMActive || user.FCMToken == "" {
		return fmt.Errorf("user FCM not active")
	}

	// Send FCM (no-op if not configured)
	if w.fcmSender != nil {
		err := w.fcmSender.SendNotification(user.FCMToken, reminder.Title, reminder.Description)
		if err != nil {
			// Check if token error
			if isTokenError(err.Error()) {
				// Mark user as inactive
				_ = w.userRepo.MarkFCMInactive(ctx, user.ID)
				return fmt.Errorf("FCM token invalid, user marked inactive: %w", err)
			}
			return fmt.Errorf("failed to send FCM notification: %w", err)
		}
	}

	return nil
}
```

## 8. Helper Functions
```go
// isSystemFCMError checks if error is a system-level FCM error
func isSystemFCMError(err error) bool {
	if err == nil {
		return false
	}
	msg := strings.ToLower(err.Error())
	return strings.Contains(msg, "credentials") ||
		strings.Contains(msg, "configuration") ||
		strings.Contains(msg, "permission")
}

// isTokenError checks if error is related to FCM token
func isTokenError(errMsg string) bool {
	msg := strings.ToLower(errMsg)
	return strings.Contains(msg, "token") ||
		strings.Contains(msg, "registration") ||
		strings.Contains(msg, "not registered")
}
```

## 9. Worker Struct Definition
```go
// Worker handles background processing of reminders
type Worker struct {
	sysRepo      repository.SystemStatusRepository
	reminderRepo repository.ReminderRepository
	userRepo     repository.UserRepository
	fcmSender    services.FCMSender
	schedCalc    services.ScheduleCalculator
	interval     time.Duration
}
```

## üìç File Location
T·∫•t c·∫£ code tr√™n n·∫±m trong file: `internal/worker/worker.go`

## üîó Dependencies
- `repository` package: Database access
- `services` package: Business logic v√† FCM
- `models` package: Data structures
- `time`: X·ª≠ l√Ω th·ªùi gian
- `log`: Logging
- `fmt`: String formatting

## ‚öôÔ∏è Configuration
Worker interval ƒë∆∞·ª£c c·∫•u h√¨nh trong file `.env`:
```env
WORKER_INTERVAL=60  # Th·ªùi gian gi·ªØa c√°c l·∫ßn ch·∫°y (gi√¢y)
```